# API Endpoint Environment Variable Refactoring Plan

## Step 1: Implement a failing test for reading API endpoints from .env file
- Create a new test file named 'envConfigTest.js' in the test directory
- Write a test that attempts to read an API endpoint from process.env and expects it to be defined
- This test should fail initially as we haven't set up the .env file or modified any JavaScript files yet

## Step 2: Create and configure the .env file
- In the root directory of the project, create a new file named '.env'
- Identify all hardcoded API endpoints in the JavaScript files within the /Users/gpanagiotopoulos/ModularDemo/ModularBankingDemo directory
- For each unique endpoint, add a corresponding entry in the .env file using the format API_ENDPOINT_NAME=https://api.example.com/endpoint
- Ensure that each endpoint has a descriptive and unique name

## Step 3: Install and set up dotenv package
- If not already present, install the dotenv package using npm or yarn
- In the main entry point of the application (likely app.js or index.js), import and configure dotenv at the very top of the file with require('dotenv').config()
- This step ensures that the environment variables from the .env file are loaded into process.env before any other code runs

## Step 4: Refactor the first JavaScript file to use environment variables
- Choose one JavaScript file from the /Users/gpanagiotopoulos/ModularDemo/ModularBankingDemo directory
- Identify all hardcoded API endpoints in this file
- For each endpoint, replace the hardcoded URL with process.env.API_ENDPOINT_NAME, where API_ENDPOINT_NAME corresponds to the name you gave the endpoint in the .env file
- Ensure that no other code is modified during this process
- After refactoring, run the test created in Step 1 to verify that the endpoints are now being read from the environment variables

## Step 5: Systematically refactor remaining JavaScript files
- Repeat the process from Step 4 for each remaining JavaScript file in the /Users/gpanagiotopoulos/ModularDemo/ModularBankingDemo directory
- For each file, identify hardcoded endpoints, replace them with references to process.env variables, and ensure no other code is altered
- After each file is refactored, run all tests to ensure functionality remains unchanged and that endpoints are correctly read from environment variables

## Step 6: Review and validate changes
- After all files have been refactored, perform a comprehensive review of the changes
- Use git diff or a similar tool to inspect each modified file, ensuring that only the intended changes related to API endpoint refactoring have been made
- Verify that no other functionality or code unrelated to URL refactoring has been altered
- Run the full test suite to confirm that all tests pass and the application's behavior remains consistent with its pre-refactored state

## Step 7: Update documentation and finalize
- Update any relevant documentation, including README files or inline comments, to reflect the new use of environment variables for API endpoints
- Add instructions for setting up the .env file in the project's documentation
- Commit the changes, including the new .env.example file (with placeholder values) but excluding the actual .env file from version control
- Finally, run a last round of manual testing to ensure the application functions correctly with the refactored endpoint configuration

JOLT Spec Generator Implementation Plan
==========================================

Step 1: Implement a failing test for JSON validation and JOLT generation
- Create a new test file 'joltGenerator.test.js' in the '/Users/gpanagiotopoulos/ModularDemo/ModularBankingDemo/__tests__' directory
- Write a test that expects an error when invalid JSON is provided
- Write another test that expects a JOLT specification when valid input and output JSON are provided
- These tests should fail initially, as the implementation doesn't exist yet

Step 2: Create utility functions for JSON validation and JOLT generation
- Create a new file 'joltGenerator.js' in the '/Users/gpanagiotopoulos/ModularDemo/ModularBankingDemo/src/utils/' directory
- Implement a function 'validateJSON' that checks if the provided input is valid JSON
- If not valid, it should throw an error
- Create a placeholder function 'generateJOLT' that takes input and output JSON as parameters
- These functions will be called from the UI when the generate JOLT button is pressed

Step 3: Implement the LLM call functionality
- In the same 'joltGenerator.js' file, create an async function 'callLLM' that uses the Azure OpenAI credentials from the .env file
- This function should take the input JSON, output JSON, and instructions as parameters
- Use the streaming API to get the response
- Ensure error handling is in place for network issues or API errors

Step 4: Update the UI components to integrate the new functionality
- Modify the relevant React component(s) to add event handlers for the "Generate JOLT" button
- When clicked, it should first validate the JSON in both input and output boxes using the 'validateJSON' function
- If valid, it should call the 'generateJOLT' function, which in turn calls 'callLLM'
- Use React state to manage the streaming response in the Generated JOLT specification box

Step 5: Implement error handling and user feedback
- Create a new component for displaying errors and notifications to the user
- This component should be used to show validation errors for invalid JSON input
- Also handle any errors that occur during the LLM API call
- Ensure that error messages are clear and actionable for the user

Step 6: Style the new components and update existing ones
- Maintain consistency with the Temenos color template
- Use the specified colors (#5CB8B2, #8246AF, and #283275) as the primary palette for the UI elements
- Ensure that the new error/notification component and the JOLT specification box are visually harmonious with the existing design
- Maintain readability and accessibility

Step 7: Refactor and optimize the implementation
- Review the code for adherence to clean code principles and language idioms
- Ensure proper separation of concerns between UI components and business logic
- Optimize the LLM call function for performance, considering factors like debouncing user input and caching results where appropriate
- Update the tests to cover edge cases and ensure all functionality is working as expected

Implementation Status:
- [ ] Step 1: Create failing tests
- [ ] Step 2: Create utility functions
- [ ] Step 3: Implement LLM call functionality
- [ ] Step 4: Update UI components
- [ ] Step 5: Implement error handling
- [ ] Step 6: Style components
- [ ] Step 7: Refactor and optimize 